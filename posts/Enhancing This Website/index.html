<!DOCTYPE html><html lang="en"><head><title>Mozahler - The Next Level</title><meta name="twitter:title" content="Mozahler - The Next Level"/><meta name="og:title" content="Mozahler - The Next Level"/><meta charset="UTF-8" name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/pure-min.css" integrity="sha384-oAOxQR6DkCoMliIh8yFnu25d7Eq/PHS21PClpwjOTeU2jRSq11vu66rf90/cZr47" crossorigin="anonymous"/><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/grids-responsive-min.css"/><link rel="stylesheet" href="/styles.css"/></head><body><div id="layout" class="pure-g"><div><div class="pure-menu pure-menu-horizontal pure-u-1-1 top-header"><a class="pure-menu-heading" href="/">Mozahler</a><ul class="pure-menu-list"><li class="pure-menu-item"><a class="pure-menu-link" href="/posts">Posts</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="/publish">Publish</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="/swift">Swift</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="/about">About This Site</a></li></ul></div></div><div class="sidebar pure-u-1 pure-u-md-1-4"><div class="header"><div id="layout" class="pure-g"><div class="author__avatar"><img src="../../images/Mozahler.jpg"/></div><div class="pure-u-md-1-1 pure-u-3-4"><h1 class="brand-title">Mozahler</h1><h3 class="brand-tagline">The Next Level</h3></div></div><div id="layout" class="pure-g"><div class="pure-u-md-1-1"><a href="https://en.wikipedia.org/wiki/Boston"><i class="fas fa-map-marker-alt l-box social-icon"></i><a class="social-media" href="https://en.wikipedia.org/wiki/Boston">Boston, Massachusetts, USA</a></a></div><div class="pure-u-md-1-1"><a href="mailto:mozahleri@gmail.com"><i class="fas fa-envelope-open-text l-box social-icon"></i><a class="social-media" href="mailto:mozahleri@gmail.com">Email</a></a></div><div class="pure-u-md-1-1"><a href="https://www.linkedin.com/in/thomas-ingemanson-8900a31b0"><i class="fab fa-linkedin l-box social-icon"></i><a class="social-media" href="https://www.linkedin.com/in/thomas-ingemanson-8900a31b0">LinkedIn</a></a></div><div class="pure-u-md-1-1"><a href="https://github.com/mozahler"><i class="fab fa-github-square l-box social-icon"></i><a class="social-media" href="https://github.com/mozahler">GitHub</a></a></div><div class="pure-u-md-1-1"><a href="https://stackoverflow.com/users/5156054/mozahler"><i class="fab fa-stack-overflow l-box social-icon"></i><a class="social-media" href="https://stackoverflow.com/users/5156054/mozahler">StackOverflow</a></a></div><div class="pure-u-md-1-1"><a href="https://twitter.com/Mozahler"><i class="fab fa-twitter-square l-box social-icon"></i><a class="social-media" href="https://twitter.com/Mozahler">Twitter</a></a></div></div></div></div><div class="content pure-u-1 pure-u-md-3-5 pure-u-xl-6-10"><h2 class="post-title"><a href="/posts/Enhancing This Website">Using Regular Expressions for Matching</a></h2><p class="post-meta">11.11.2022</p><div class="post-tags"><a class="post-category post-category-tests tutorial" href="/tags/tests-tutorial">tests tutorial</a></div><div class="post-description"><div><h2>An Example of What I Could Add Next</h2><p>I'm planning on making tutorials a feature of this blog. I have quite a few of them under development in various states of completion. You can see one that I put together earlier this year already posted on my GitHub pages.</p><p><a href="https://github.com/Mozahler/FloodFill">Mozahler - FloodFill</a><br><br>At the bottom of this page you can see a partial list of other potential projects. If you would like to see one of them published, then drop me an email by using the link located below my avatar. Please share your thoughts.<br>˙</p><h2>My Current Project</h2><p>In case you didn't check out my earlier tutorial on the Flood Fill algorithm, let me show you a portion of the project I'm currently working on. This is an excerpt/demo from a possible multi-part tutorial that uses <strong>Wordle</strong> as a demonstration app to discuss a number of Swift-related topics. This should give you some idea of my approach and you can decide if you like it or not.</p><p>In my <strong>Wordle</strong> tutorial I use the popular game as the focus of a project defined as a single <strong>Swift Package</strong> which tangentially covers a number of technologies, best practices, unit testing, Swift Animation, configuring Fastlane and more. Most important is that the end product is a complete app.<br>˙</p><h4>... An Excerpt from the Wordle Tutorial</h4><p>For those who have studied Swift in school, but haven't had a chance to take things to the next level, the is a complete example describing how to create an iOS app, covering many bases - enough to get your app into the store.<br><br>In this extract/demo, I touch upon<br><br>- <strong>Regular Expressions</strong> and <strong>Pattern Matching</strong><br>- <strong>Unit Tests</strong> in Xcode<br>- Using <strong>Swift Package Manager</strong> to modularize your work<br>- Organizing your code by applying the principles of <strong>Swift Composable Architecture (TCA)</strong><br><br>Upon completing the tutorial you would have created a <strong>Swift Package</strong> containing all the code for a complete Wordle app (including tests) written using SwiftUI and relying on SwiftComposableArchitecture that runs on a real device (iPhone or iPad) or simulator.</p><h2>The Color-Coded Tiles</h2><p>I'm going to discuss some of the rules of the game here, but if you are unfamiliar with the gameplay, you should definitely play a few games yourself before reading further. None of this is very complicated, but you shouldn't be trying to conquer multiple concepts simultaneously.</p><p>The object of the game is to guess the solution - a five-letter word selected by the app when you start the game. You take a turn by typing in five-letters (they have to represent real words, and they have to be in the game's main list of vetted words). The NYT has curated a list which removes possibly offensive words (pussy) and has recently revised their rules to not allow simple plurals (3 letters plus <strong>es</strong> or 4 letters plus <strong>s</strong>). Geese for goose is still valid.</p><p>When you take a turn, or submit a guess by tapping on the <strong>submit</strong> button, the app cycles through your 5 tile choices, matching them against the solution. It colors the tiles based on whether and where the letter appears in the solution. By applying what you know about the color category, you can mentally narrow down the list of possible solutions. The object of the game is to guess the solution in as few turns as possible. And you're only allowed six chances to do so.</p><p>Let's take a minute to understand how a tile turns a particular color before coming up with code that puts it all together.˙</p><h2>The Yellow Tile</h2><p>A yellow tile signifies that the letter is represented in the solution, but is not in the correct position.</p><p>This, surprisingly, gives you a lot of information. It can be a bit frustrating to apply it, though. We know that if a tile is yellow that this particular letter appears at least once in the final solution. Knowing that it is in the wrong place is also useful, if as I mentioned, a bit frustrating. If there are 3 yellows and 2 greens, then you know you have all the letters you need for the solution, and can avoid wasting a turn by trying out new letters.</p><h2>The Black Tile</h2><p>It is incredibly useful to know what letters aren't in the word. You can still submit the letter in any subsequent guesses (to help construct a word using unused letters - remember it has to be a valid word before you're allowed to submit it!) The problem is that there are 26 possible letters and you only get 6 attempts. You don't want to waste too much energy eliminating letters from consideration.</p><p>Personally, at the start of the game I like to submit two guesses using the most frequent letters in American English (including most of the vowels). This means I rarely solve a word in under 3 guesses. It also means that I have most of the vowels and possibly a few of the consonants by the third guess. Keep in mind that the game on the NYT is edited/curated which introduces a certain bias. And be aware that the most used first guess is <strong>Adieu</strong>.<br>˙</p><h2>The Green Tile</h2><p>Green is gold in this context. A green tile is by far the most useful, and it signifies that you have the letter and the position exactly right.</p><p>It doesn't mean that you are done with this letter - think of double <strong>oo</strong>, <strong>ee</strong>, <strong>ll</strong>, <strong>mm</strong>, <strong>ss</strong>, not to mention non-consecutive letters, like <strong>banal</strong> or <strong>smash</strong>. But it gives you a chance to relax a bit as it confirms you are on the right track.</p><p>The most useful aspect of the green tile is that you also have positional information. Applying this information gives you the best opportunity to whittle down the size of the main list (pool of candidates). However, this also means processing this information takes a bit more ingenuity, or at least a better data structure than just a simple array of letters.</p><h1>Using Regular Expressions for Matching</h1><p>If you're a mathematician, you might prefer to use the advanced capabilities of working with Swift's RegularExpression that have been added with Swift 5.7 (Xcode 14+). For the rest of us (I got into computer science because I prefer letting the machine do the math), the minimal required knowledge will do. I'll go into what that means shortly.</p><p>Regular Expressions deserve a unit to themselves. Support for Regular Expressions is very robust in Swift, and for good reason. RegExes provide coded shortcuts to identify sequences of characters by using a mix of special wildcard characters along with the characters you wish to match against.</p><p>There are wildcard characters that will match your string against multiple occurrences of a subsequence in a row. You can specify that there should be exactly <strong>one</strong> match of the sequence in the string being checked. There's even a wildcard to tell you that the next character in the sequence is not a wildcard. (the backslash '')</p><h2>The Yellow Tiles</h2><p>Let's take a look at how we might encode a sequence that includes three yellow tiles <strong>s</strong>, <strong>r</strong> and <strong>e</strong>.</p><p>Regular expressions contain a special sequence which is called <strong>lookahead</strong>. You precede the potential match with a question mark and equal sign, and surround the entire subsequence with parens.<br><br>It is special in that it will look at the pending match and see if it can find the sequence, but it doesn't <strong>eat</strong> the sequence (in other words, the sequence remains intact for other possible searches). This is perfect for taking our list of candidates and only including those with <strong>yellow</strong> matches.</p><p>so three yellow letters <strong>SRE</strong> translate to:</p><pre><code>  (?=.*s.*)(?=.*r.*)(?=.*e.*)
</code></pre><p>If this is enough to get you started, then by all means go off and code a different solution from the one that follows.<br><br>This might be fine for some people, but I'm going to want to code something a bit less cryptic.</p><p>That's not to say I won't be using regular expressions in my solution. I just won't use such esoteric sequences. I also won't be looking at the entire sequence at once. I will cycle through each of the five positions in the string. This way I only have to match one character at a time. Our working domain of less than 5000 five-letter words doesn't demand the most efficient approach possible, and I prefer to work with code I can understand when I first view it.</p><p>The two special characters I will use to accomplish this are <strong>[</strong> and <strong>]</strong>. In the RegEx world this means any of the characters between the brackets can match. If I don't follow with sequence with any special characters to indicate frequency, this will only match against one character. The previous definition for matching yellow <strong>sre</strong> is now represented as</p><pre><code>[sre]
</code></pre><p>Let's say I have my yellow tile letters from my current turn and I want to remove all the words in the main list that don't contain these letters. After all, I'm trying to reduce the candidate pool with each turn.<br><br>All I need to do is wrap these letters inside square brackets and then filter the list using the regular expression just mentioned. The result is understandable Swift code.<br><br><br>In order to make that happen, I need to write this <strong>yellow()</strong> method.</p><pre><code>    <span class="comment">/// returns all items with the any of the specified letters in it</span>
    <span class="keyword">func</span> yellow(<span class="keyword">_</span> yellowChars: <span class="type">String</span> = <span class="string">"[SRE]"</span>) -&gt; [<span class="type">String</span>] {
        mainList.<span class="call">filter</span>({ 
            $0.<span class="call">range</span>(of: yellowChars, 
            options: .<span class="dotAccess">regularExpression</span>) != <span class="keyword">nil</span> 
        })
    }
</code></pre><p>Using the filter method on the Array&lt;String&gt;, I iterate through all the words in the main list and only return those words that contain at least one of these letters (the result of the match is non-nil).<br><br>starting here we lose the headlines again (adding this line brought them back)</p><h2>The Black Tiles</h2><pre><code>     <span class="keyword">func</span> black(<span class="keyword">_</span> blackChars: <span class="type">String</span> = <span class="string">"[EIOUY]"</span>) -&gt; [<span class="type">String</span>] {
        mainList.<span class="call">filter</span>({ $0.<span class="call">range</span>(of: blackChars, options: .<span class="dotAccess">regularExpression</span>) == <span class="keyword">nil</span> })
    }
</code></pre><p>This is very similar to the yellow method. Instead of including entries that match, entries are included only if there is not a match against any of the characters in the reference string.</p><h2>The Green Tiles</h2><p>I will provide two solutions using two different data structures to process the green tiles.</p><p>In this first (less object-oriented) approach I will be working with an array of optional strings. (I'll leave it as an exercise for the reader if you prefer working with optional characters)<br>˙</p><pre><code><span class="keyword">var</span> solvedLetters: [<span class="type">String</span>?] = [<span class="keyword">nil</span>, <span class="keyword">nil</span>, <span class="keyword">nil</span>, <span class="keyword">nil</span>, <span class="keyword">nil</span>]
</code></pre><p>The advantages of this simplistic approach is that you have position information (all five tiles are represented, albeit without individual labels) which allow for direct iteration through the elements of the <strong>solvedLetters</strong> array.</p><p>Taking the passed in parameter and iterating through its elements, we can quickly reduce the size of the pool of candidates by eliminating all words that don't have <strong>green</strong> letters in the indicated position. We simply skip over processing an empty/nil element.</p><pre><code>    <span class="keyword">func</span> green(<span class="keyword">_</span> greenChars: [<span class="type">String</span>?]) {
        <span class="keyword">for</span> (index, item) <span class="keyword">in</span> greenChars.<span class="call">enumerated</span>() {
            <span class="keyword">if let</span> item {
                mainList = mainList.<span class="call">filter</span>({ $0[index] == item })
            }
        }
</code></pre><p>Personally I prefer a more object oriented solution, and my final solution makes use of a <strong>Tile</strong> object which includes its letter's position within the final solution.<br><br><br><strong><em>[the second solution omitted in this excerpt]</em></strong></p><h2>Give Me Your Feedback!</h2><p>If you followed along and found my explanations useful, let me know. If I glossed over a point you don't quite get, drop me a line. Click on my email link (below my avatar)<br>˙</p><h2>Potential Projects</h2><ul><li>Wordle</li><li>A SwiftUI Picker Using SF Symbols</li><li>FloodFill Algorithm (what is missing from the published project?)</li><li>Combine</li><li>The Swift Concurrency Model and Structured Concurrency</li><li>SwiftComposableArchitecture (TCA)</li><li>Parsing Markdown (Using the parser library from PointFree)</li><li>Xcode Unit Tests</li><li>SwiftUI Property Wrappers</li><li>SwiftUI View Builders</li><li>Javascript and iOS</li><li>Refactoring</li><li>JSON and REST APIs</li></ul><p>As I mentioned earlier, I have a number of tutorials in various stages of completion, and I am also coming up with new ideas as I see new APIs and tools become available.<br>˙</p><h2>Links</h2><p><a href="https://www.google.com/search?&rls=en&q=swift+array+remove+matching+element&ie=UTF-8&oe=UTF-8">Google Search</a><br><br><a href="https://github.com/Mozahler/FloodFill">Mozahler - FloodFill</a><br><br><a href="https://www.theverge.com/2022/2/15/22934587/wordle-solutions-changed-new-york-times">Wordle Solutions Changed</a></p></div></div></div><div class="footer pure-u-1"><div class="pure-u-1">© 2022 Mozahler</div><div class="pure-u-1">Generated using <a href="https://github.com/johnsundell/publish">Publish</a></div><div class="pure-u-1"><a href="/feed.rss">RSS feed</a></div></div></div></body></html>